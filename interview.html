<!DOCTYPE html>
<html>
<head>
<title>面试技能收集</title>
<!-- 2014-12-10 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<link rel="Stylesheet" type="text/css" href="assets/css/style.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript">
    function show_org_source(){
       /* document.location.href = rpl(document.location.href,"html","org.html"); */
       var url = document.location.href.split('#')[0];
       document.location.href = url.replace(/.html$/, '.org.html');
    }
</script>
</head>
<body>
<div id="preamble" class="status">
<!--<body onload="prettyPrint()">-->
<nav>
    <a href="index.html">Index</a>
    <a href="about.html">About</a>
    <a href="https://lotabout.github.io">Blog</a>
    <a href="sitemap.html">SiteMap</a>
</nav>
</div>
<div id="content">
<h1 class="title">面试技能收集</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">C/C++</a>
<ul>
<li><a href="#sec-1-1">Cast</a>
<ul>
<li><a href="#sec-1-1-1">dynamic_cast</a></li>
<li><a href="#sec-1-1-2">static_cast</a></li>
<li><a href="#sec-1-1-3">reinterpret_cast</a></li>
<li><a href="#sec-1-1-4">const_cast</a></li>
<li><a href="#sec-1-1-5">Conclusion</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Library</a>
<ul>
<li><a href="#sec-1-2-1">static vs shared library</a></li>
</ul>
</li>
<li><a href="#sec-1-3">sizeof</a></li>
<li><a href="#sec-1-4">如何防止类被实例化</a></li>
<li><a href="#sec-1-5">如何防止类被继承</a></li>
</ul>
</li>
<li><a href="#sec-2">Python</a>
<ul>
<li><a href="#sec-2-1">装饰器 Decorator</a></li>
</ul>
</li>
<li><a href="#sec-3">Network</a>
<ul>
<li><a href="#sec-3-1">TCP/UDP</a>
<ul>
<li><a href="#sec-3-1-1">Establish TCP connection(Three-way handshake)</a></li>
<li><a href="#sec-3-1-2">Termination of TCP connection</a></li>
</ul>
</li>
<li><a href="#sec-3-2">从输入URL到浏览器显示，后台发生了什么</a></li>
</ul>
</li>
<li><a href="#sec-4">Linux System Programming</a>
<ul>
<li><a href="#sec-4-1">IPC(Inter-Process Communication)</a>
<ul>
<li><a href="#sec-4-1-1">PIPE</a></li>
<li><a href="#sec-4-1-2">FIFO</a></li>
<li><a href="#sec-4-1-3">message queue</a></li>
<li><a href="#sec-4-1-4">shared memory</a></li>
<li><a href="#sec-4-1-5">semaphore</a></li>
<li><a href="#sec-4-1-6">Deadlock</a></li>
</ul>
</li>
<li><a href="#sec-4-2">线程与进程</a></li>
<li><a href="#sec-4-3">进程调度</a>
<ul>
<li><a href="#sec-4-3-1">参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本页旨在记录准备面试过程中学习的知识。
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">C/C++</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Cast</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">dynamic_cast</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<code>dynamic_cast</code> can only be used with pointers and references to
classes(or with <code>void *</code>)
</p>

<ul class="org-ul">
<li>It is naturally includes <span class="underline">pointer upcast</span> (converting from
pointer-to-derived to pointer-to-base), in the same way as
allowed as an <span class="underline">implicit conversion</span>
</li>
<li>It can also <span class="underline">downcast</span> (convert from pointer-to-base to
pointer-to-derived) polymorphic classes(those with virtual
members) if and only if the pointed object is a valid complete
object of the target type. (Normally this means that it can convert
pointer-to-base that is previously converted from pointer-to-derived.)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">static_cast</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<code>static_cast</code> can perform conversion between pointers to related
classes, not only <span class="underline">upcast</span> but also <span class="underline">downcast</span>. No checks are
performed during runtime to guarentee that the object being
converted is in fact a full object of the destination type.
</p>

<p>
<code>static_cast</code> is also able to perform all conversions allowed
implicitly(not only those with pointers to classes), and is also
able to perform the opposite of these.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">reinterpret_cast</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
<code>reinterpret_cast</code> converts any pointer type to any other pointer
type, even of unrelated classes. The operation result is a simple
binary copy of the value from one pointer to the other.
</p>

<p>
It can also cast pointers to or from integer type.
</p>

<p>
The conversions that can be performed by <code>reinterpret_cast</code> but
not by <code>static_cast</code> are low-level operations based on
reinterpreting the binary representations of the types. which on
most cases results in code which is system-specific, and thus
non-portable. For example:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">A</span> { <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">... */</span> };
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">B</span> { <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">... */</span> };
<span style="font-weight: bold; text-decoration: underline;">A</span> * <span style="font-weight: bold; font-style: italic;">a</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">A</span>;
<span style="font-weight: bold; text-decoration: underline;">B</span> * <span style="font-weight: bold; font-style: italic;">b</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;B*&gt;(a);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">const_cast</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
This type of casting manipulates the constness of the object
pointed by a pointer, either to be set or to be removed.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">Conclusion</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
Use <code>dynamic_cast</code> to ensure target type. <code>static_cast</code> to do most
implicit casting.
</p>

<p>
Non-pointer objects can only be casted by <code>static_cast</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Library</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">static vs shared library</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
For more information <sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>.
</p>

<ul class="org-ul">
<li>Dll(shared) pros: can be used to reuse/share code between
several products; load in the process memory on demand and can
be unloaded when not needed; can be upgrade independently of the
rest of the program
</li>
<li>Dll cons: performance impact of the dll loading and code
rebasing; versioning problem("dll hell")
</li>
<li>Lib(static) pros: no performance impact as code is always loaded
in the process and is not rebased; no versioning problems.
</li>
<li>Lib cons: executable/process "bloat" &#x2013; all the code is in your
executable and is loaded upon process start, no reuse/sharing &#x2013;
each product has its own copy of code.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">sizeof</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<code>sizeof</code> will calculate in-memory size of an object. So when
applying it to STL objects, it will results in the sizeof STL
container itself instead of the size of all its elements. Example
(on 64bit machine):
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;iostream&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;string&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;vector&gt;</span>

<span style="font-weight: bold;">using</span> <span style="font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">std</span>;

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[])
{
    <span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">str</span> = <span style="font-style: italic;">"abcdefgaaaaaaaaaaaa"</span>;
    cout &lt;&lt; <span style="font-style: italic;">"sizeof(str) = "</span> &lt;&lt; <span style="font-weight: bold;">sizeof</span>(str) &lt;&lt; endl;
    <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">vec</span>(100);
    cout &lt;&lt; <span style="font-style: italic;">"sizeof(vec(100)) = "</span> &lt;&lt; <span style="font-weight: bold;">sizeof</span>(vec) &lt;&lt; endl;
    <span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt; <span style="font-weight: bold; font-style: italic;">cvec</span>(100);
    cout &lt;&lt; <span style="font-style: italic;">"sizeof(cvec(100)) = "</span> &lt;&lt; <span style="font-weight: bold;">sizeof</span>(cvec) &lt;&lt; endl;

    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">如何防止类被实例化</h3>
<div class="outline-text-3" id="text-1-4">
<ol class="org-ol">
<li>Make the class an abstract class by including at least one <span class="underline">pure
virtual</span> function.
</li>
<li>Make the constructor of a class private, and then create a
static function which will return some instantances of the
class. If only one instance of the class is allowed, we should
also keep a reference to this instance in the class
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">如何防止类被继承</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Reasons of preventing derived classes:
</p>
<ol class="org-ol">
<li>Mark a class as non-subclassable so you can safely use a
non-virtual destructor and avoid a vtable altogether.
</li>

<li><a href="http://stackoverflow.com/questions/2184133/prevent-class-inheritance-in-c">Prevent class inheritance in C++</a>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Python</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">装饰器 Decorator</h3>
<div class="outline-text-3" id="text-2-1">
<p>
python 中的decorator本质上就是包装函数 <code>wrap</code> ，以被包装函数 <code>fn</code>
为参数，返回一个包装后的函数并赋给 <code>fn</code> 。
</p>

<p>
例<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>：
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">hello</span>(fn):
<span style="background-color: #bebebe;"> </span>   <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">wrapper</span>():
        <span style="font-weight: bold;">print</span> <span style="font-style: italic;">"hello, %s"</span> % fn.<span style="font-weight: bold;">__name__</span>
        fn()
        <span style="font-weight: bold;">print</span> <span style="font-style: italic;">"goodby, %s"</span> % fn.<span style="font-weight: bold;">__name__</span>
<span style="background-color: #bebebe;"> </span>   <span style="font-weight: bold;">return</span> wrapper
<span style="font-weight: bold; text-decoration: underline;">@hello</span>
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">foo</span>():
<span style="background-color: #bebebe;"> </span>   <span style="font-weight: bold;">print</span> <span style="font-style: italic;">"i am foo"</span>

foo()
</pre>
</div>

<p>
这里 <code>@hello</code> 的语法想当于执行了 <code>func = decorator(func)</code> ，即
<code>decorator</code> 以函数 <code>func</code> 为参数，返回包装后的参数。注意到这里最后
的赋值，所以它相当于lisp里的 <code>(set! func (decorator func))</code> <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>，
而相比于使用 <code>set!</code> 的 <code>lisp</code> 实现，python的优势在于简化了语法。
</p>

<p>
函数 <code>decorator</code> 本身也可以接收参数：
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="font-weight: bold; text-decoration: underline;">@decorator</span>(arg1, arg2)
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">func</span>():
<span style="background-color: #bebebe;"> </span>   <span style="font-weight: bold;">pass</span>
</pre>
</div>
<p>
相当于:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">func</span> = decorator(arg1, arg2)(func)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Network</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">TCP/UDP</h3>
<div class="outline-text-3" id="text-3-1">
<p>
UDP(User Datagram Protocol) is used to provide multiplexing for
processes in a host.
</p>

<p>
UDP uses &lt;host, port&gt; to identify a process.
</p>

<p>
The <b>end-to-end argument</b>: it is one of the most important
principles in system design. It says that a function(in network,
providing reliable/ordered delivery) should not be provided in
lower levels unless it can be completely and correctly implemented
at that level. However it does allow for functions to be
incompletely provided at lower level as performance
optimization. This is why it is perfectly consistent with
end-to-end argument to perform error detection(e.g. CRC) on a
hop-to-hop basis. Detecting and retransmiting a single corrupt
packet accross one hop is more preferable to having to
retransmiting an entire file end-to-end.
</p>

<p>
TCP's demux key is given by &lt;srcPort, srcIP, dstPort, dstIP&gt;.
</p>

<p>
Check <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP frame</a> for frame structure.
</p>

<p>
Because TCP is byte-oriented protocol, each byte has a sequence
number, the <span class="underline">Sequence Number</span> field carrys the sequence number of
the first byte of the segment.
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Establish TCP connection(Three-way handshake)</h4>
<div class="outline-text-4" id="text-3-1-1">
<pre class="example">
Client =&gt; Server/Client &lt;= Server
1. =&gt; SYN, SequneceNum = x
2. &lt;= SYN+ACK, SequenceNum = y, Acknowledgement = x+1
3. =&gt; ACK, Acknowledgement = y+1
</pre>

<p>
The SequenceNums are the starting sequence numbers the two sides
plan to use for their respective byte stream.
</p>

<ol class="org-ol">
<li>Note that even if the 3rd packet is lost, the connection is
still OK to use, because after the 2nd step, the client's state
is changed to ESTABLISHED. And every packet contains an
<span class="underline">Acknowledge</span> number, and it will turn the server into
ESTABLISHED after the first packet from client is received.
</li>
<li>Most sender will set a timer after sending some packet, and if
after several tries the expected response does not arrive, TCP
give up and returns to the CLOSED state.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Termination of TCP connection</h4>
<div class="outline-text-4" id="text-3-1-2">

<div id="fig:tcp-close" class="figure">
<p><img src="images/TCP_CLOSE.png" alt="TCP_CLOSE.png">
</p>
<p><span class="figure-number">Figure 1:</span> Connection termination</p>
</div>

<p>
The state changes:
</p>
<pre class="example">
This side closes first:
ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED
That side closes first:
ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED
Both side close at the same time:
ESTABLISHED -&gt; FIN_WAIT_1 -&gt; CLOSING -&gt; TIME_WAIT -&gt; CLOSED
</pre>

<p>
Note that the connection cannot move from TIME_WAIT to CLOSED
until it has waited for two times the maximum amount of the an IP
datagram can live on the internet(i.e. 120s). The reason is that
while the local side(on the left of the image) of the connection
has sent an ACK in response of the other side's FIN segment, it
does not know that the ACK was successfully delivered. As a
consequence, the other side might retransmit its FIN segment, and
this second FIN segment might be delayed in the internet. If the
connection is allowed to move directly to CLOSED state, then
another application might came along and use the same connection,
and the delayed FIN segment might immediatly initiate the
termination of the newly created connection.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">从输入URL到浏览器显示，后台发生了什么</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<a href="http://www.cnblogs.com/rollenholt/archive/2012/03/23/2414345.html">百度面试题：从输入url到显示网页，后台发生了什么？</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Linux System Programming</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">IPC(Inter-Process Communication)</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">PIPE</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The atomicity of <code>write</code> of pipe is controled by <code>PIPE_BUF</code>, if
the size of written is less than or equal to <code>PIPE_BUF</code>, then the
written processes is ensured to be atomic. Otherwise, the data
written by different processes might overlap.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">FIFO</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
FIFO can exist even after the processes quit. The remaining
feature is more or less the same to PIPE.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">message queue</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Note the behavior of <code>msgrcv</code> if the buffer size is less than the
size of message in message queue. <code>man msgrcv</code> to find more details.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">shared memory</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Still, notice the behavior of <code>shmget</code> if the required size is
greater than the size of already created shared memory.
</p>

<p>
Also shared memory is <code>critical area</code>, i.e. a client might be
reading while the server is writing. Thus shared memory is often
combined with semaphore to do synchronization.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5">semaphore</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
How to avoid deadlock?
</p>

<p>
=&gt; UNIX uses the "All or nothing" mechanism. That means you either
get all the resources or nothing at all. You should request all
the resources at the same time and if one of them is blocked you
may not get any of the others.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-6" class="outline-4">
<h4 id="sec-4-1-6">Deadlock</h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
The
<a href="http://en.wikipedia.org/wiki/Deadlock#Necessary_conditions">Four
conditions</a> should all hold in a system for deadlock to occur:
</p>
<ol class="org-ol">
<li>Mutal Exclusion :: At least one resource must be held in a
non-shareable mode. Only one process can use the resource at
any given instant of time.
</li>
<li>Hold and Wait or Resource Holding :: A process is currently
holding at least one resource and requesting additional
resources which are being held by other processes.
</li>
<li>No Preemption :: A resource can be released only voluntarily by
the process holding it, after that process has
completed its task.
</li>
<li>Circular Wait :: A process must be waiting for a resource which
is being held by another process, which in
turn waiting for the first process to release
the resource.
</li>
</ol>
<p>
Unfulfillment of <b>any</b> of these conditions is enough to preclude a
deadlock from occurring.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">线程与进程</h3>
<div class="outline-text-3" id="text-4-2">
<p>
进程是系统分配资源的基本单位，线程是系统调度的基本单位。
</p>

<p>
<b>联系</b>
</p>

<ol class="org-ol">
<li>一个进程至少拥有一个线程──主线程，也可以拥有多个线程。一个线程
必须有一个父进程。多个进程可以并发执行，一个线程可以创建和撤销另
一个线程，同一个进程中的多个线程可以并发执行。
</li>
<li>同一进程中的所有线程共享该进程的所有资源。但各自拥有自己的堆栈。
</li>
<li>线程的同步方式与进程相同，但可以额外地使用全局变量来同步。
</li>
</ol>

<p>
<b>区别</b>
</p>

<ol class="org-ol">
<li>系统开销：创建或删除 <span class="underline">进程</span> 时，由于系统需要分配和回收资源，所以
开销明显大于线程的创建和删除。
</li>
<li>资源管理：若一个进程崩溃，在保护模式下不会影响其它进程。而线程没
有单独的地址空间，崩溃之后进程也随之崩溃。因此多进程方式比多线程
更健壮。但线程切换耗费更大的资源。
</li>
<li>通信方式：进程间通信主要包括PIPE，FIFO，System V IPC(Message
Queue, Shared Memory, Semaphore)，socket通信。这些方法同样适用于
线程间通信，但对于同一进程的不同线程，使用全局变量进行通信的效率
更高。
</li>
</ol>

<p>
<b>参考</b>
</p>
<ul class="org-ul">
<li><a href="http://blog.csdn.net/xiexievv/article/details/7294189">进程与线程的区别与联系</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">进程调度</h3>
<div class="outline-text-3" id="text-4-3">
<p>
请描述一下进程是如何调度的。
</p>
<dl class="org-dl">
<dt> 先来先服务（FCFS） </dt><dd>即先来的任务先运行，后来的不可抢占，直到前
面的任务完成为止。特点是简单，但效率低；对长作业有利，对短作业
不利；CPU繁忙型有利，I/O繁忙型不利。
</dd>
<dt> 短作业优先（SJF） </dt><dd>从队列中选择一个或若干个估计运行时间短的作业
运行。平均等待时间短，平均周转时间短。但长作业不利，有时甚至永
远无法得到运行；未考虑进行的紧迫性；估算时间不准确。
</dd>
<dt> 优先级调度算法 </dt><dd>为进程分配优先级，代表紧迫程度，依据不同的子策
略（如是否可抢占）有不同的子算法。
</dd>
<dt> 高响应比优先调度算法 </dt><dd>是对FCFS和SJF的一个平衡，对队列中的进程计
算响应比，并选取最小的一个或几个先运行。
</dd>
<dt> 时间片轮转调度算法 </dt><dd>选择就绪队列中的一个进程，按先到先得的策略，
但每个进程每次只能运行一个时间片，之后就移动到队列的末尾。该算
法与时间片的选择有关，如时间片过大，则退化成FCFS算法。
</dd>
<dt> 多级反馈队列调度算法 </dt><dd>它根据不同的优先级创建了不同的就绪队列，
进程的优先级动态进行调整。当优先级高的队列空的时候才运行优先级
低的队列。任务之间是可以抢占的。
</dd>
</dl>
</div>

<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">参考</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li><a href="http://see.xidian.edu.cn/cpp/html/2595.html">操作系统典型调度算法</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://www.cplusplus.com/doc/tutorial/typecasting/">C++ type casting</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://stackoverflow.com/questions/140061/when-to-use-dynamic-vs-static-libraries">When to use dynamic vs. static libraries</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="http://coolshell.cn/articles/11265.html">Python 修饰器的函数式编程</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="racket_notes.html#sec-4-1">racket_notes.html#sec-4-1</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<a href="#" class="back-to-top">Back to Top</a>

<!-- <hr class="comment"> -->
<!-- <div id="show_source"> -->
<!--   <input type="button" value="Show Org source" onClick='show_org_source()'> -->
<!-- </div> -->

</script>
<hr class="comment">
<section class="comment">
<!-- An element a visitor can click if they <3 comments! -->
<button class="btn show-comments">Load Disqus comments</button>
<div id="disqus_thread"></div>
 
<!-- The empty element required for Disqus to loads comments into -->
<!--<div id="disqus_thread"></div>-->
    <!--<script type="text/javascript">-->
        <!--/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */-->
        <!--var disqus_shortname = 'lotaboutvimwiki'; // required: replace example with your forum shortname-->

        <!--/* * * DON'T EDIT BELOW THIS LINE * * */-->
        <!--(function() {-->
            <!--var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;-->
            <!--dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';-->
            <!--(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);-->
        <!--})();-->
    <!--</script>-->
    <!--<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>-->
</section>

<footer>
    |采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a>授权|由<a href="http://orgmode.org">Org Mode</a>自动生成<input type="button" value="Show Org source" onClick='show_org_source()'>|部署在<a href="https://github.com/lotabout/orgwiki">Github Pages</a>|
</footer>

    <script src="assets/js/jquery-1.7.1.min.js"></script>
    <script>
$(document).ready(function(){
	var offset = 100;
	var duration = 110;

        $(window).resize(function () {
            var toc= $('#table-of-contents')
            if ($(window).width() <= 800) {
                toc.css('position', 'static')
	        return
            }
            });
        $(window).scroll(
            function () {
            console.log("scroll called.")
            var toc= $('#table-of-contents')
            if ($(window).width() <= 800) {
            toc.css('position', 'static')
            return
            }

            if ($(this).scrollTop() > duration) {
            toc.css('left', toc.position().left + 'px')
            toc.css('position', 'fixed')
            $('.back-to-top').fadeIn(duration);
            } else {
            toc.css('left', '0px')
            toc.css('top', '0px')
            toc.css('position', 'relative')
            $('.back-to-top').fadeOut(duration);
            }
            });
        $('.back-to-top').click(
            function(event) {
            event.preventDefault;
            $('html, body').animate({scrollTop: 0}, duration);
            return false;
            });

        $('.show-comments').on('click', function(){
                               var disqus_shortname = 'lotaboutorgwiki'; // Replace this value with *your* username.

                               // ajax request to load the disqus javascript
                               $.ajax({
type: "GET",
url: "http://" + disqus_shortname + ".disqus.com/embed.js",
dataType: "script",
cache: true
});
                               // hide the button once comments load
                               $(this).fadeOut();
                               });
});
    </script>
</div>
</body>
</html>
