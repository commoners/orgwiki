<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>clojure_web_development.org</title>
    <style type="text/css">
    <!--
      body {
        color: #dcdccc;
        background-color: #3f3f3f;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .hl-line {
        /* hl-line */
        background-color: #404040;
      }
      .org-block {
        /* org-block */
        color: #b3b3b3;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #7f9f7f;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #7f9f7f;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #b3b3b3;
      }
      .org-document-title {
        /* org-document-title */
        color: #afeeee;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #dfaf8f;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #8fb28f;
      }
      .org-verbatim {
        /* org-verbatim */
        color: #b3b3b3;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword"><span class="hl-line">#+title:</span></span><span class="hl-line"> </span><span class="org-document-title"><span class="hl-line">Clojure Web Development
</span></span>
Note that much of the contents are from book "Web Development with Clojure".

<span class="org-level-1">* Ring</span>
Ring applications contains four basic components: the <span class="bold">*handler*</span>, the <span class="bold">*request*</span>,
the <span class="bold">*response*</span> and the <span class="bold">*middleware*</span>.

The handler are functions that process the incoming requests. They accept
request maps and return response maps.

<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defn handler [request-map]
    {:status 200
     :headers {"Content-Type" "text/html"}
     :body (str "&lt;html&gt;&lt;body&gt; your IP is: "
                (:remote-addr request-map)
                "&lt;/body&gt;&lt;/html&gt;")})
</span><span class="org-block-end-line">#+end_src
</span>
The above code accept a HTTP request which is represented by a clojure map. Then
it serves an HTML string with the client's IP address and sets the response
status to 200.

Note that the underground of Web Applications are parsing HTTP requests and
generating HTTP responses. So the Ring is here to simplify this process.

The above operation is so common that Ring API provides a helper function for
generating such responses:

<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defn handler [request-map]
    (response
     (str "&lt;html&gt;&lt;body&gt; your IP is: "
          (:remote-addr request-map)
          "&lt;/body&gt;&lt;/html&gt;")))
</span><span class="org-block-end-line">#+end_src
</span>
So all that <span class="org-verbatim">=response=</span> does is simplify the process of creating a response map
just like we've did in the last example. And that's it and nothing else.

<span class="org-level-2">** Middleware</span>
A middleware handler is a function that accepts an existing handler with some
optional parameters, then returns a new handler with some added
behavior. Example:

<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defn handler [request]
    (response
     (str "&lt;html&gt;&lt;body&gt; your IP is:(:remote-addr request)
  "&lt;/body&gt;&lt;/html&gt;")))
  "
  (defn wrap-nocache [handler]
    (fn [request]
      (let [response (handler request)]
        (assoc-in response [:headers "Pragma"] "no-cache"))))
  (def app (wrap-nocache handler))

</span><span class="org-block-end-line">#+end_src
</span>
<span class="org-level-1">* Compojure</span>
Compojure is a routing library built on top of Ring. It provides an easy way to
associate handler functions with a URL and an HTTP method. A route might look
like:
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (GET "/:id" [id] (str "&lt;p&gt;the id is " id "&lt;/p&gt;"))
</span><span class="org-block-end-line">#+end_src
</span>There are several HTTP methods: GET, POST, PUT, DELETE and HEAD.

In the above example, <span class="org-verbatim">=GET=</span> is a function provided by <span class="org-verbatim">=compojure.core=</span>. It takes
some arguments and return a Ring handler. So we don't have to deal with the
details of a HTTP request or response(such as status, headers) with the help of
a route. We can think in a higer level, i.e. URL or HTTP method.

Since we're likely to have more than one single route in our application,
compojure provides the <span class="org-verbatim">=routes=</span> function that create a Ring handler from
multiple routes.

<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defn foo-handler []
    "foo called")

  (defn bar-handler [id]
    (str "bar called, id is: " id))

  (def handler
    (routes
     (GET "/foo" [] (foo-hanler))
     (GET "/bar/:id" [id] (bar-handler id))))
</span><span class="org-block-end-line">#+end_src
</span>
Well, normally we'll need a route(or called a hander) to deal with one
function(for example one HTML page). But we will want to have a hander to
combine all these handlers and dispatch requests accordingly. So that is what
<span class="org-verbatim">=routes=</span> does.

Compojure simplify defining routes more over:
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defroutes handler
    (GET "/foo" [] (foo-handler))
    (GET "/bar/:id" [id] (bar-handler id)))
</span><span class="org-block-end-line">#+end_src
</span>
<span class="org-level-2">** Accessing Request Parameters</span>
If some routes need to access the request map to access the request parameters,
we can declare the map as the second argument to the route.
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (GET "/foo" request (interpose ", " (keys request)))
</span><span class="org-block-end-line">#+end_src
</span>
Fetching parameters from a request is quite common, so compojure support
destructuring feature for route definition:
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (POST "/" [name message] (save-message name message))

  ;;; or
  (GET "/:foo" {{value "name"} :params} (str "The value of name is " value))
  (GET "/" [x y :as r] (str x y r))
</span><span class="org-block-end-line">#+end_src
</span>
Armed with Ring and Compojure, we can easily create pages and routes for our
site. However, any nontrival application requires many other features, such as
page templating, session management, and input validation. We'll seek for other
utilities to finish that.

<span class="org-level-1">* Application Architecture</span>
The major components that will be present in most applications are as follows:
- handler -- This namespace is responsible for handling requests and responses.
- routes -- The routes contain the core of our application, such as the logic to
  render pages and handle client requests
- model -- This namespace is reserved for the data model of the application and
  the persistencce layer
- views -- This namespace contains common logic for generating the applcation layout.


<span class="org-level-1">* Liberator</span>

A set of keys defined by the Liberator application programming interface
represents each resource. Specific actions are in turn associated with each
key. A key can fall into one of four categories:
- Decision
- Handler
- Action
- Declaration
Each key can be associated with either constants or fucntions. The functions
should accept a single parameter that is the current contex, and return a
variety of responses.

<span class="org-level-2">** Decision</span>
The decisions are used to figure out how to handle the client request. The
decision keys end with a question mark (?) and their handler must evaluate to a
boolean value.

1. A boolean value is returned indicating the result of the decision
2. A map is returned. The decision is assumed to have been evaluated to <span class="org-verbatim">=true=</span>
   and the contents of the map are merged with the response map.
3. A vectore is returned. It must contain a boolean value indicating the
   outcome, followed by a map to be mreged with the response.

When any decision has a negtive outime, its corresponding HTTP code will be
returned to the client.
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defresource home
    :service-available? false
    :handle-ok "Hello World"
    :etag "fixed-etag"
    :available-media-types ["text/plain"])
</span><span class="org-block-end-line">#+end_src
</span>If we reload the page, we'll see the 503 response type associated with the
<span class="bold">*Service not available*</span> response.

<span class="org-level-2">** Creating Handlers</span>
A handler function should return a standard Ring response. Handler keys start
with the <span class="org-verbatim">=handle-=</span> prefix. The <span class="org-verbatim">=handle-ok=</span> key in the previous example belongs
to handle keys.

For example, if we wanted to return a specific response when the service is not
available, we could do the following:
<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (defresource home
    :service-available? false
    :handle-service-not-available
    "Service is currently unavailable...")
</span><span class="org-block-end-line">#+end_src
</span>
<span class="org-level-2">** Taking Actions</span>
An action represents an update of the current state by the client, such as a
PUT, POST or DELETE request. The action keys end with an exclamation point(!) to
indicate that they're mutating the application's internal state.

Once an action occurs, we can return the result to the client using the
<span class="org-verbatim">=handle-creat=</span> handler.

<span class="org-level-2">** Declaration</span>
Declarations are used to indicate that resource's capabilities. For example, our
resource uses the <span class="org-verbatim">=available-media-type=</span> declaration to specify that it returns
a response of type <span class="org-verbatim">=text/plain=</span>.

<span class="org-level-1">* Ring Notes</span>
How to send response with <span class="org-verbatim">=edn=</span> format? With the default setup by luminus, we
only need to do this:

<span class="org-block-begin-line">#+begin_src clojure
</span><span class="org-block">  (GET "/comments" [] (-&gt; (response {:data @comments})
                          (header "Content-Type" "Application/edn")))
</span><span class="org-block-end-line">#+end_src
</span>
That is: send a response and replace its <span class="org-verbatim">=Content-Type=</span> in the header to
<span class="org-verbatim">=Application/edn=</span>, and that is done.
</pre>
  </body>
</html>
