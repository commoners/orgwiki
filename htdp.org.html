<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>htdp.org</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .hl-line {
      }
      .org-block {
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        font-weight: bold;
        font-style: italic;
      }
      .org-block-end-line {
        /* org-block-end-line */
        font-weight: bold;
        font-style: italic;
      }
      .org-document-info-keyword {
      }
      .org-document-title {
        /* org-document-title */
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        font-weight: bold;
      }
      .org-level-2 {
        /* org-level-2 */
        font-weight: bold;
        font-style: italic;
      }
      .org-level-3 {
        /* org-level-3 */
        font-weight: bold;
      }
      .org-link {
        /* org-link */
        text-decoration: underline;
      }
      .org-meta-line {
        /* org-meta-line */
        font-weight: bold;
        font-style: italic;
      }
      .org-verbatim {
      }
      .underline {
        /* underline */
        text-decoration: underline;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword"><span class="hl-line">#+TITLE:</span></span><span class="hl-line"> </span><span class="org-document-title"><span class="hl-line">How to Design Programs Notes
</span></span>
<span class="org-level-1">* Design Functions</span>
<span class="org-level-2">** Information and Data</span>
Information can be thought as facts about the program's domain, while data is
just a "literal" representation.

Take temperature as an example. `100` is only a prepresentation or data. We
know nothing only by looking at this literal. When the data is `interpretted`
in the domain of temperature, we know it means 100C or 100F. On the other
hand, computers or programs cannot understand 100C or 100F directly. We then
can `represent` it as a number `100` or strings link `100C` or `100F`, these are
what computers can understand.

<span class="org-level-2">** Process of Designing Functions</span>
<span class="bold">*-&gt;*</span> This process can be guideline of writing comments for functions.

- Express how information is represented as data.
<span class="org-block-begin-line">  #+BEGIN_EXAMPLE
</span><span class="org-block">  ; we use plain numbers to represent temperatures.
</span><span class="org-block-end-line">  #+END_EXAMPLE
</span>- Write down a signature, a purpose statement, and a function header.
  A <span class="underline">_signature_</span> is like `haskell`'s function type.
<span class="org-block-begin-line">  #+BEGIN_EXAMPLE
</span><span class="org-block">  ; String -&gt; Number
</span><span class="org-block-end-line">  #+END_EXAMPLE
</span>  <span class="underline">_Purpose statement_</span> is a short line to describe the purpose of a function. A
  better way to express this is to use descriptive names for functions.
  <span class="underline">_Function Header_</span> is the header of a function without its implementation.
- Illustrate the signature and the purpose statement with some functional
  examples.
<span class="org-block-begin-line">  #+BEGIN_EXAMPLE
</span><span class="org-block">  ; Number -&gt; Number                                      ; signature
  ; compute the area of a square whose side is len        ; purpose
  ; given: 2, expect: 4                                   ; examples
  ; given: 7, expect: 49
  (define (area-of-square len) 0)                         ; header
</span><span class="org-block-end-line">  #+END_EXAMPLE
</span>
- The next step is considering what and how are we going to compute. This is
  done by inserting <span class="bold">*templates*</span> in the function body(for example, the ones
  introduced in the following chapters).
- Now <span class="underline">_code_</span>. Fill in the information needed by the template and other
  details.
- Last one: Test the functions. (in racket or other script languages, directly
  make some unit test cases is quite simple, do it!)
  
<span class="org-level-2">** Domain Knowledge</span>
   Two forms of <span class="underline">_domain knowledge_</span>:
   - Knowledge from external domains.
   - Knowledge about the library functions in the chosen programming language.

<span class="org-level-3">*** From Functions to Programs</span>
The `car` problem: Design a program that moves a car across the world canvas,
from left to right, at the rate of three pixels per clock tick.

How to tare down the problem into program elements:
1. Find out constant staff and assign them to global constant variables.
2. Find out properties that change over time. Design how to represent them with
   data. (can we call them <span class="underline">_states_</span>?)
3. Design a number of functions to handle al these variable properties.
4. write a <span class="underline">_main_</span> function so as to connect real world to our programs.
  
We can conclude it into 4 elements when designing:
1. global states(constants).
2. data representation for states.
3. actions to handle states.
4. main function.

<span class="org-level-3">*** Designing World Programs</span>
    Why is modifying the sample problem and adding mouse event handler
    is so straightforward? First it strictly separate the *model*(the
    data that a program tracks) and the *view*(how the program show
    results). Second is the design recipes for programs and functions
    organize programs in the right way.
    
    This teaches us two leason: 
    1. separate our modules.
    2. correctly organize our design recipes.(including data and
       functions, etc.)
       
<span class="org-level-1">* Intervals, Enumerations, Itemizations</span>
  Why we need these? Often, we'll need to design programs with
  restrictions on our built-in collections. One way to restrict it is
  to enumerate a bunch of elements form a collection and to say that
  these are the only ones that we are going to use. However,
  enumeration will work only under finite number of elements, thus we
  need intervals for "infinately" many elements.
  
<span class="org-level-2">** Conditional Computations</span>
   Review the <span class="org-verbatim">=cond=</span> expression:
<span class="org-block-begin-line">   #+BEGIN_SRC scheme
</span><span class="org-block">     (cond
      [condition-expr-1 result-expr-1]
      [condition-expr-2 result-expr-2]
      ...
      [condition-expr-n result-expr-n])
</span><span class="org-block-end-line">   #+END_SRC
</span>   In may problem contexts, a function must distinguish several
   different situations. With a <span class="org-verbatim">=cond=</span> expression expression, you can
   use one line per possiblity and thus <span class="underline">_remaind the reader of the
   code of the different situations from the problem statement_</span>.

   Contrast <span class="org-verbatim">=cond=</span> with <span class="org-verbatim">=if=</span>. we use <span class="org-verbatim">=if=</span> is more suited when we want
   to say "one or the other".
   
   Note that even if we can code with either one and the result is OK,
   don't do it! Codes are read not only by machine, but also by
   human. Thus express the idea directly and clearly is important.
   
   For example, in C language, using <span class="org-verbatim">=switch=</span> would be more expressive
   than nested <span class="org-verbatim">=if=</span> statements.
   
<span class="org-level-2">** How it works</span>
<span class="org-block-begin-line">   #+BEGIN_QUOTE
</span>   Just looking at the <span class="org-verbatim">=cond=</span> expression you cannot predict which of
   the three <span class="org-verbatim">=cond=</span> clause is going to be used._And that is the point
   of a function._<span class="org-meta-line">
</span><span class="org-block-end-line">   #+END_QUOTE
</span>
   
<span class="org-level-2">** Enumerations</span>
   The main idea of an enumeration is that it defines a collection of
   data as a <span class="bold">*finite*</span> number of pieces of data. So we can iterate
   through all its possibilities with a <span class="org-verbatim">=cond=</span> branch. This is the
   <span class="bold">*template*</span> of dealing with enumerations.
   
   Example(From the book):
<span class="org-block-begin-line">#+BEGIN_SRC scheme
</span><span class="org-block">; A TrafficLight shows one of three colors:
; &#8211; "red"
; &#8211; "green"
; &#8211; "yellow"
; interp. each element of TrafficLight represents which colored
; bulb is currently turned on

; TrafficLight -&gt; TrafficLight
; given state s, determine the next state of the traffic light
 
(check-expect (traffic-light-next "red") "green")
 
(define (traffic-light-next s)
  (cond
    [(string=? "red" s) "green"]
    [(string=? "green" s) "yellow"]
    [(string=? "yellow" s) "red"]))
</span><span class="org-block-end-line">#+END_SRC
</span>   There are 3 states of <span class="org-verbatim">=TrafficLight=</span>, thus we generate 3 <span class="org-verbatim">=cond=</span> branches.
   
   <span class="bold">*-&gt;*</span> <span class="org-link"><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html#%28counter._%28figure._fig~3acond-enum%29%29">[[</a><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html#%28counter._%28figure._fig~3acond-enum%29%29">http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html#%28counter._%28figure._fig~3acond-enum%29%29</a><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_one.html#%28counter._%28figure._fig~3acond-enum%29%29">]]</a></span>
   
   Note the difference between these two implementation. The book
   talked about the <span class="underline">_re-order_</span> of the condition lines. It also says
   that <span class="underline">_Naturally, this kind of re-arrangement is done </span><span class="underline"><span class="bold">*after*</span></span><span class="underline"> the
   function is designed properly._</span>
   
   I think the <span class="bold">*essence*</span> here is maintain the information of the same
   level in the same level of <span class="org-verbatim">=cond=</span> expression. That means in this
   <span class="org-verbatim">=cond=</span> we only cares about the information: what keys do we care
   about? And condition <span class="org-verbatim">=( = (string-length k) 1)=</span> do not belong to
   this class of informaiton, thus we through it into the <span class="org-verbatim">=else=</span>
   branch. And we may generate a sub <span class="org-verbatim">=cond=</span> expression in <span class="org-verbatim">=else=</span>
   branch if needed.
   
<span class="org-level-2">** Intervals</span>
   The main concept here contains two parts:
   1. the difference between <span class="underline">_interval_</span> and <span class="underline">_enumeration_</span> is
      <span class="underline">_interval_</span> may contain <span class="bold">*infinate*</span> number of elements.
   2. However, we can represent <span class="underline">_intervals_</span> in <span class="bold">*finite*</span> cases, each
      can be specified by a boundary check function.
   
   That means when contruct <span class="org-verbatim">=cond=</span> expression for these two cases, the
   main difference is how to write the <span class="underline">_condition expressions_</span>.
<span class="org-block-begin-line">   #+BEGIN_SRC scheme
</span><span class="org-block">     ; for enumeration
     (define (iter-enumeration x)
       (cond
        [(= x 1) 1]
        [(= x 2) 2]
        [else 3]))

     ; for intervals
     (define (iter-interval x)
       [(&lt; x 10) 1]
       [(&lt; x 100) 2]
       [else 3])

     ; the main difference here is *=* and *&lt;*
</span><span class="org-block-end-line">   #+END_SRC
</span>   
<span class="org-level-2">** Itemization</span>

<span class="org-level-1">* Lists</span>

<span class="org-block-begin-line">  #+BEGIN_QUOTE
</span>    Then again, if this list is supposed to represent a record with a fixed
    number of pieces, use a structure type instead.<span class="org-meta-line">
</span><span class="org-block-end-line">  #+END_QUOTE
</span>    
This means that when designing programs, use lists oly when the number of
items is variable. Otherwise, choose <span class="underline">_struct_</span>, <span class="underline">_vector_</span>, etc. instead.

<span class="org-level-1">* Designing With Self-referential Data Definitions</span>

This chapter talks about the design of new self-referential data(or
recursively defined data). And how to walk through all the elements of a
specific data.

Also the book gave out a "template" for designing functions for
self-referential data.

<span class="bold">*-&gt;*</span> Most data structures comes with a patter, and there also exists a pattern
 of how to deal with it. This is what we called a template.
<span class="org-link"><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html#%28counter._%28figure._fig~3adesign5%29%29|Designing a function for self-referential data">[[</a><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html#%28counter._%28figure._fig~3adesign5%29%29|Designing a function for self-referential data">http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html#%28counter._%28figure._fig~3adesign5%29%29|Designing a function for self-referential data</a><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_two.html#%28counter._%28figure._fig~3adesign5%29%29|Designing a function for self-referential data">]]</a></span>


</pre>
  </body>
</html>
